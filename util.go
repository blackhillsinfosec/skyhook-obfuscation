package obfuscate

import (
	"crypto/cipher"
	"github.com/mitchellh/mapstructure"
	"reflect"
	"strings"
)

// blockEncrypt is a convenience function to encrypt data
// using cipher.Block objects.
func blockEncrypt(c cipher.Block, input []byte) (output []byte) {

	bSize := c.BlockSize()
	for len(input) >= bSize {

		//===============================
		// EXTRACT BLOCK AND RESIZE INPUT
		//===============================

		block := input[:bSize]
		input = input[bSize:]

		//=================================
		// ENCRYPT BLOCK AND CAPTURE OUTPUT
		//=================================

		buff := make([]byte, bSize)
		c.Encrypt(buff, block)
		output = append(output, buff...)
	}

	//==============================================
	// PAD REMAINING BYTES TO BLOCK SIZE AND ENCRYPT
	//==============================================

	padData(&input, bSize)
	buff := make([]byte, bSize)
	c.Encrypt(buff, input)
	output = append(output, buff...)

	return output
}

// blockDecrypt is a convenience function to decrypt data
// using cipher.Block objects.
func blockDecrypt(c cipher.Block, input []byte) (output []byte) {
	bSize := c.BlockSize()
	for len(input) > 0 {
		block := input[:bSize]
		input = input[bSize:]
		buff := make([]byte, bSize)
		c.Decrypt(buff, block)
		output = append(output, buff...)
	}
	unpadData(&output)
	return output
}

// padData handles padding for output generated by cipher.Block
// objects. It follows a bootleg variation of _padding method 2_
// as described in ISO/IEC 9797-1:
//
// # If the final block of the cipher text is too small
//
// - A 0x01 byte is appended to the end
// - blockSize-chunkLen 0x00 bytes are appended
func padData(b *[]byte, size int) {
	// Append a single 1
	*b = append(*b, 0x01)

	// Expand the block to the expected size
	if len(*b) < size {
		*b = append(*b, make([]byte, size-len(*b))...)
	}
}

// unpadData handles unpadding of data padded by padData,
// effectively removing padding when needed.
func unpadData(b *[]byte) {
	i := len(*b) - 1
	for ; i > -1 && (*b)[i] != 0x01; i-- {
		// NOP - just read backward until 0x01 is found
	}
	if i != -1 {
		// i will be -1 when b has no bytes
		*b = (*b)[:i]
	}
}

// ObfuscatorConfig represents a configuration for an Obfuscator.
type ObfuscatorConfig struct {
	Algo   string                 `nonzero:"" mapstructure:"algo" json:"algo" yaml:"algo"`
	Config map[string]interface{} `nonzero:"" mapstructure:"config" json:"config" yaml:"config"`
}

// ParseObfuscators parses a slice of ObfuscatorConfig structs into
// a chain of Obfuscator objects.
func ParseObfuscators(obfConfigs *[]ObfuscatorConfig) (chain *[]Obfuscator, failures []string) {

	chain = new([]Obfuscator)
	var conf ObfuscatorConfig
	for _, conf = range *obfConfigs {
		if obfs, mapped := MapToAlgorithm(conf.Algo); !mapped {
			failures = append(failures, conf.Algo)
		} else {
			// TODO we should probably do some form of validation here.
			if err := mapstructure.WeakDecode(conf.Config, &obfs); err != nil {
				failures = append(failures, conf.Algo)
			} else {
				*chain = append(*chain, obfs)
			}
		}

	}

	return chain, failures

}

// UnparseObfuscators parses a slice of objects that implement obfuscate.Obfuscator
// and returns a slice of pointers to ObfuscatorConfig structs.
func UnparseObfuscators(obfs *[]Obfuscator) *[]ObfuscatorConfig {
	var configs []ObfuscatorConfig
	for _, obf := range *obfs {

		// Initialize an obfuscator config
		con := map[string]interface{}{}

		// Use reflect to introspect the target obfuscator
		v := reflect.ValueOf(obf).Elem()
		t := v.Type()

		for i := 0; i < v.NumField(); i++ {

			//======================
			// RETRIEVE TYPE & VALUE
			//======================

			// Get the field's current reflect value
			fV := v.Field(i)
			// Get the name of the field from the type
			fName := strings.ToLower(t.Field(i).Name)

			//==============
			// SET THE VALUE
			//==============
			// TODO this will likely need to be updated as
			//    new algorithms are added/modified

			// Set the value to the target member based
			// on the field's concrete type.
			switch fV.Type().String() {
			case "string":
				con[fName] = fV.String()
			case "uint":
				con[fName] = uint(fV.Uint())
			case "int":
				con[fName] = int(fV.Int())
			}
		}

		configs = append(configs, ObfuscatorConfig{
			Algo:   strings.ToLower(t.Name()),
			Config: con,
		})
	}

	return &configs
}

// MapToAlgorithm maps the name of an obfuscation algorithm back to
// the proper type.
func MapToAlgorithm(name string) (o Obfuscator, ok bool) {

	switch strings.ToLower(name) {
	case "xor":
		o = new(XOR)
	case "base64":
		o = new(Base64)
	case "blowfish":
		o = new(Blowfish)
	case "aes":
		o = new(AES)
	case "twofish":
		o = new(Twofish)
	}

	return o, o != nil
}
